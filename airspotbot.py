import tweepy
import configparser
import logging
from time import sleep, time
import adsbget

# TODO: write functions to generate spot tweets based on adsbexchange api data
# TODO: write functions to pull supplementary information (registration, photos) for spots and add in tweet replies

logging.basicConfig(level=logging.INFO, format='%(asctime)s - %(levelname)s: %(message)s', datefmt='%d-%b-%y %H:%M:%S')


class SpotBot:
    def __init__(self, config_file_path):
        self.config_file_path = config_file_path
        self.interval = 5
        self.consumer_key = None
        self.consumer_secret = None
        self.access_token = None
        self.access_token_secret = None
        self.use_descriptions = False
        self.reply_jetphotos = False
        self.down_tweet = False
        self.twitter_config = self.read_twitter_config()
        self.api = self.initialize_twitter_api()

    def initialize_twitter_api(self):
        # Authenticate to Twitter
        logging.info(f'Twitter consumer key: {self.consumer_key}')
        logging.info(f'Twitter consumer secret: {self.consumer_secret}')
        logging.info(f'Twitter access token: {self.access_token}')
        logging.info(f'Twitter access token secret: {self.access_token_secret}')
        auth = tweepy.OAuthHandler(self.consumer_key, self.consumer_secret)
        auth.set_access_token(self.access_token, self.access_token_secret)
        api = tweepy.API(auth, wait_on_rate_limit=True, wait_on_rate_limit_notify=True) # Create API object
        try:
            # test that authentication worked
            api.verify_credentials()
            logging.info("Authentication OK")
        except tweepy.error.TweepError as e:
            logging.critical(f'Error during Twitter API authentication')
            raise e
        logging.info('Twitter API created')
        return api

    def read_twitter_config(self):
        parser = configparser.ConfigParser()
        parser.read(self.config_file_path)  # read config file at path
        try:
            self.interval = int(parser.get('TWITTER', 'tweet_interval'))
            self.consumer_key = parser.get('TWITTER', 'consumer_key')
            self.consumer_secret = parser.get('TWITTER', 'consumer_secret')
            self.access_token = parser.get('TWITTER', 'access_token')
            self.access_token_secret = parser.get('TWITTER', 'access_token_secret')
            if parser.get('TWITTER', 'use_descriptions').lower() == 'y':
                self.use_descriptions = True
            elif parser.get('TWITTER', 'use_descriptions').lower() == 'n':
                self.use_descriptions = False
            else:
                raise ValueError()
            if parser.get('TWITTER', 'reply_jetphotos').lower() == 'y':
                self.reply_jetphotos = True
            elif parser.get('TWITTER', 'reply_jetphotos').lower() == 'n':
                self.reply_jetphotos = False
            else:
                raise ValueError()
            if parser.get('TWITTER', 'down_tweet').lower() == 'y':
                self.down_tweet = True
            elif parser.get('TWITTER', 'down_tweet').lower() == 'n':
                self.down_tweet = False
            else:
                raise ValueError()
        except (configparser.NoOptionError, configparser.NoSectionError) as e:
            logging.critical(f'Configuration file error: {e}')

    def tweet_spot(self, aircraft: dict):
        icao, type_code, reg_num, lat, lon, description, alt, speed = aircraft['icao'], aircraft['type'], aircraft['reg'], aircraft['lat'], aircraft['lon'], aircraft['desc'], aircraft['alt'], aircraft['spd']
        link = f'https://tar1090.adsbexchange.com/?icao={icao}'
        location = str(round(float(lat), 4)) + ', ' + str(round(float(lon), 4))
        # TODO: function to tweet out aircraft spots
        if reg_num.strip() == '':
            reg = 'unknown'
        if type_code.strip() == '':
            type_code = 'Unknown aircraft type'
        tweet = f"{description if description else type_code} (ICAO {icao}, RN {reg_num}) is near {location}. Altitude {alt} ft, speed {speed} kt. {link}"
        logging.info(f'Tweeting: {tweet}')
        try:
            self.api.update_status(tweet)
        except tweepy.error.TweepError as e:
            logging.critical('Error sending tweet')
            raise e
        if self.reply_jetphotos:
            self.photo_reply()

    def photo_reply(self, tweet=None, reg_num=None):
        # TODO: function to reply to a tweet generated by tweet_spot with a link to any jetphotos.com results
        pass

    def link_reply(self):
        # TODO: function to reply to to a tweet generated by tweet_spot with a link defined in watchlist.csv
        pass


if __name__ == "__main__":
    bot = SpotBot('asb.config')
    spots = adsbget.Spotter('asb.config', 'watchlist.csv')
    bot_time = time()
    spot_time = time()
    # check for aircraft and tweet any when bot first starts
    spots.check_spots()
    for i in range(0, len(spots.spot_queue)):
        spot = spots.spot_queue.pop(0)
        bot.tweet_spot(spot)
    # perpetually loop through checking aircraft spots and tweeting according to time intervals set in asb.config
    while True:
        if time() > spot_time + spots.interval:
            spots.check_spots()
            spot_time = time()
        elif time() > bot_time + bot.interval:
            for i in range(0, len(spots.spot_queue)):
                spot = spots.spot_queue.pop(0)
                bot.tweet_spot(spot)
            bot_time = time()
        else:
            sleep(1)






