import tweepy
import configparser
import logging
from time import sleep, time
import adsbget

# TODO: write functions to generate spot tweets based on adsbexchange api data
# TODO: write functions to pull supplementary information (registration, photos) for spots and add in tweet replies

logging.basicConfig(level=logging.INFO)

class SpotBot:
    def __init__(self, config_file_path):
        self.config_file_path = config_file_path
        self.interval = 5
        self.consumer_key = None
        self.consumer_secret = None
        self.access_token = None
        self.access_token_secret = None
        self.use_descriptions = False
        self.reply_jetphotos = False
        self.down_tweet = False
        self.twitter_config = self.read_twitter_config()
        self.api = self.initialize_twitter_api()

    def initialize_twitter_api(self):
        # Authenticate to Twitter
        logging.info(f'Twitter consumer key: {self.consumer_key}')
        logging.info(f'Twitter consumer secret: {self.consumer_secret}')
        logging.info(f'Twitter access token: {self.access_token}')
        logging.info(f'Twitter access token secret: {self.access_token_secret}')
        auth = tweepy.OAuthHandler(self.consumer_key, self.consumer_secret)
        auth.set_access_token(self.access_token, self.access_token_secret)
        api = tweepy.API(auth, wait_on_rate_limit=True, wait_on_rate_limit_notify=True) # Create API object
        try:
            # test that authentication worked
            api.verify_credentials()
            logging.info("Authentication OK")
        except tweepy.error.TweepError as e:
            logging.critical(f'Error during Twitter API authentication')
            raise e
        logging.info('Twitter API created')
        return api

    def read_twitter_config(self):
        # TODO: function for reading and storing variables/keys from asb.config
        parser = configparser.ConfigParser()
        parser.read(self.config_file_path)  # read config file at path
        try:
            self.interval = int(parser.get('TWITTER', 'tweet_interval'))
            self.consumer_key = parser.get('TWITTER', 'consumer_key')
            self.consumer_secret = parser.get('TWITTER', 'consumer_secret')
            self.access_token = parser.get('TWITTER', 'access_token')
            self.access_token_secret = parser.get('TWITTER', 'access_token_secret')
            if parser.get('TWITTER', 'use_descriptions').lower() == 'y':
                self.use_descriptions = True
            elif parser.get('TWITTER', 'use_descriptions').lower() == 'n':
                self.use_descriptions = False
            else:
                raise ValueError()
            if parser.get('TWITTER', 'reply_jetphotos').lower() == 'y':
                self.reply_jetphotos = True
            elif parser.get('TWITTER', 'reply_jetphotos').lower() == 'n':
                self.reply_jetphotos = False
            else:
                raise ValueError()
            if parser.get('TWITTER', 'down_tweet').lower() == 'y':
                self.down_tweet = True
            elif parser.get('TWITTER', 'down_tweet').lower() == 'n':
                self.down_tweet = False
            else:
                raise ValueError()
        except (configparser.NoOptionError, configparser.NoSectionError) as e:
            logging.critical(f'Configuration file error: {e}')

    def tweet_spot(self, type_code: str, reg_num: str, location: str, link: str, description=None):
        # TODO: function to tweet out aircraft spots
        description_empty = description != ''
        tweet = f"{description if not description_empty else type_code}, registration {reg_num} is near {location}. {link}"
        logging.info(f'Tweeting: {tweet}')
        self.api.update_status(tweet)

    def photo_reply(self, tweet, reg_num: str):
        # TODO: function to reply to a tweet generated by tweet_spot with a link to jetphotos.com
        pass

    def link_reply(self):
        pass


if __name__ == "__main__":
        bot = SpotBot('asb.config')
        spots = adsbget.Spotter('asb.config', 'watchlist.csv')
        bot_time = time()
        spot_time = time()
        while True:
            if ime() > spot_time + spots.interval:
                spots.check_spots()
                spot_time = time()
            if time() > bot_time + bot.interval:
                for i in range(1, len(spots.spot_queue)):
                    spot = spots.spot_queue.pop(0)
                    bot.tweet_spot(spot['type'], spot['reg'], spot['location'], spot['link'], spot['description'])
                    bot_time = time()
            sleep(1)






