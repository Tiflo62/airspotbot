import tweepy
import configparser
import logging
from time import sleep, clock
import adsbget

# TODO: write functions to generate spot tweets based on adsbexchange api data
# TODO: write functions to pull supplementary information (registration, photos) for spots and add in tweet replies

logging.basicConfig(level=logging.DEBUG)

class SpotBot:
    def __init__(self, config_file_path):
        self.config_file_path = config_file_path
        self.interval = 5
        self.consumer_key = None
        self.consumer_secret = None
        self.access_token = None
        self.access_token_secret = None
        self.use_descriptions = False
        self.reply_jetphotos = False
        self.down_tweet = False
        self.twitter_config = self.read_twitter_config()
        self.api = self.initialize_twitter_api()

    def initialize_twitter_api(self):
        # Authenticate to Twitter
        auth = tweepy.OAuthHandler(self.twitter_config['consumer_key'], self.twitter_config['consumer_secret'])
        auth.set_access_token(self.twitter_config['access_token'], self.twitter_config['access_token_secret'])
        # Create API object
        api = tweepy.API(auth, wait_on_rate_limit=True, wait_on_rate_limit_notify=True)
        try:
            # test that authentication worked
            api.verify_credentials()
            logging.info("Authentication OK")
        except tweepy.error.TweepError as e:
            logging.critical(f'Error during Twitter API authentication')
            raise e
        logging.info('Twitter API created')
        return api

    def read_twitter_config(self):
        # TODO: function for reading and storing variables/keys from asb.config
        parser = configparser.ConfigParser()
        parser.read(self.config_file_path) # read config file at path
        try:
            self.interval = int(parser.get('TWITTER', 'tweet_interval'))
            self.consumer_key = parser.get('TWITTER', 'consumer_key')
            self.consumer_secret = parser.get('TWITTER', 'consumer_secret')
            self.access_token = parser.get('TWITTER', 'access_token')
            self.access_token_secret = parser.get('TWITTER', 'access_token_secret')
            if parser.get('TWITTER', 'use_descriptions').lower() == 'y':
                self.use_descriptions = True
            elif parser.get('TWITTER', 'use_descriptions').lower() == 'n':
                self.use_descriptions = False
            else:
                raise ValueError()
            if parser.get('TWITTER', 'reply_jetphotos').lower() == 'y':
                self.reply_jetphotos = True
            elif parser.get('TWITTER', 'reply_jetphotos').lower() == 'n':
                self.reply_jetphotos = False
            else:
                raise ValueError()
            if parser.get('TWITTER', 'down_tweet').lower() == 'y':
                self.down_tweet = True
            elif parser.get('TWITTER', 'down_tweet').lower() == 'n':
                self.down_tweet = False
            else:
                raise ValueError()
        except (configparser.NoOptionError, configparser.NoSectionError) as e:
            logging.critical(f'Configuration file error: {e}')


    def tweet_spot(self, type_code: str, reg_num:str, location: str, link: str, description=None):
        # TODO: function to tweet out aircraft spots
        logging.info(f'Tweeting: "A {description if description else type_code}, registration {reg_num} is near {location}. {link}"')


    def photo_reply(self, tweet, reg_num: str):
        # TODO: function to reply to a tweet generated by tweet_spot with a link to jetphotos.com
        pass


    def link_reply:
        pass


if __name__ == "__main__":
        bot = SpotBot()
        time = clock()
        spot_queue = [] # placeholder for list of dicts provided by adsb
        while True:
            if clock() > time + adsbget.adsb_interval:
                adsbget.check_spots()
            if clock() > time + bot.interval:
                for i in range(1, len(spot_queue)):
                    spot = spot_queue.pop()
                    bot.tweet_spot(spot['type_code'], spot['reg_num'], spot['location'], spot['link'], spot['description'])







